diff --git a/Makefile b/Makefile
index 2db5bdf..16de899 100644
--- a/Makefile
+++ b/Makefile
@@ -47,9 +47,11 @@ CXX = g++ -g -I$(INCLUDE_DIR) -I$(INCLUDE_DIR)/detect -I$(INCLUDE_DIR)/heap -I$(
 
 
 # -march=core2 -msse3 -DSSE_SUPPORT 
-CFLAGS   = -Wall -msse3 -DSSE_SUPPORT -fno-omit-frame-pointer
+#CFLAGS   = -Wall -msse3 -DSSE_SUPPORT -fno-omit-frame-pointer
+CFLAGS   = -msse3 -DSSE_SUPPORT -fno-omit-frame-pointer
 CFLAGS32 = $(CFLAGS) -m32 -DX86_32BIT # -O3
-CFLAGS64 = $(CFLAGS) -m64 # -O3
+CFLAGS64 = $(CFLAGS) #-m64 # -O3
+#CFLAGS64 = $(CFLAGS) -m64 # -O3
 
 INCLUDE_DIRS = -I. -I./heaplayers -I./heaplayers/util
 
diff --git a/examples/falsesharing.cpp b/examples/falsesharing.cpp
index f58f522..6f3065b 100644
--- a/examples/falsesharing.cpp
+++ b/examples/falsesharing.cpp
@@ -5,7 +5,8 @@
 #include <iostream>
 using namespace std;
 
-enum { MAX_THREADS = 256 };
+enum { MAX_THREADS = 8 };
+//enum { NUM_ITERATIONS = 800000000 };
 enum { NUM_ITERATIONS = 80000000 };
 
 class Item {
@@ -42,7 +43,10 @@ main()
   pthread_t thread[MAX_THREADS];
 
   cout << "Starting threads." << endl;
-  cout << "theItem is at " << (void *) &theItem << endl;
+//  cout << "theItem is at " << (void *) &theItem << endl;
+  fprintf(stderr, "theItem is at %p pointing to %p\n", &theItem, theItem);
+
+  fprintf(stderr, "%d: BEFORE creation\n", getpid());
 
   for (int i = 0; i < 8; i++) {
     pthread_create (&thread[i], NULL, worker, (void *) i);
diff --git a/include/detect/xtracker.h b/include/detect/xtracker.h
index 82b27cd..b50b1b7 100644
--- a/include/detect/xtracker.h
+++ b/include/detect/xtracker.h
@@ -23,7 +23,7 @@
 #include "elfinfo.h"
 #include "stats.h"
 
-template <int NElts = 1>
+template <unsigned long NElts = 1>
 class xtracker {
   
   enum { PAGE_SIZE = 4096 };
@@ -332,7 +332,7 @@ public:
   }
 
   // It is simple for us, we just use the forward search.
-  void checkWrites(int * base, int size, struct wordchangeinfo * wordchange) {
+  void checkWrites(int * base, unsigned long size, struct wordchangeinfo * wordchange) {
     int * pos;
     int * end;
   
@@ -540,7 +540,7 @@ public:
     return ((start & xdefines::CACHELINE_SIZE_MASK) + size + xdefines::CACHE_LINE_SIZE - 1)/xdefines::CACHE_LINE_SIZE;
   }
 
-  void checkGlobalObjects(unsigned long *cacheInvalidates, int * memBase, int size, struct wordchangeinfo * wordchange) {
+  void checkGlobalObjects(unsigned long *cacheInvalidates, int * memBase, unsigned long size, struct wordchangeinfo * wordchange) {
     struct elf_info *elf = &_elf_info;  
     Elf_Ehdr *hdr = elf->hdr;
     Elf_Sym *symbol;
diff --git a/include/objecttable.h b/include/objecttable.h
index a3c8535..5692696 100644
--- a/include/objecttable.h
+++ b/include/objecttable.h
@@ -31,7 +31,7 @@
 
 #include <map>
 //#include <unordered_map>
-#include <hash_map>
+#include <ext/hash_map>
 #include <stdio.h>
 #include <callsite.h>
 #include <internalheap.h>
diff --git a/include/util/callsite.h b/include/util/callsite.h
index 9ff46eb..9e43bc8 100644
--- a/include/util/callsite.h
+++ b/include/util/callsite.h
@@ -88,6 +88,11 @@ public:
       _callsite[*frames] = tmp-5;
       (*frames)++;
     }
+    else if((*frames) >= 1) {
+      // We should stop getting callsites if we already jump out of text segment. 
+      // Otherwise, some application will crash, fixed by Tongping Liu (09/28/1012).
+      (*frames) = CALL_SITE_DEPTH;
+    }
   }
 
   /// The following function is borrowed from plug project that is written by Gene Nowark.
diff --git a/include/xdefines.h b/include/xdefines.h
index 09837e3..0aee3f4 100644
--- a/include/xdefines.h
+++ b/include/xdefines.h
@@ -108,9 +108,10 @@ class xdefines {
 public:
   enum { STACK_SIZE = 1024 * 1024 };
 #ifdef X86_32BIT
-  enum { PROTECTEDHEAP_SIZE = 1048576UL * 600 };
+  enum { PROTECTEDHEAP_SIZE = 1048576UL * 1024 };
 #else
-  enum { PROTECTEDHEAP_SIZE = 1048576UL * 8192 };
+  enum { PROTECTEDHEAP_SIZE = 1048576UL * 1024 };
+  //enum { PROTECTEDHEAP_SIZE = 1048576UL * 8192 };
 #endif
   enum { SHAREDHEAP_SIZE = 1048576UL * 100 };
 #ifndef DETECT_FALSE_SHARING
diff --git a/include/xmemory.h b/include/xmemory.h
index 3ca8a0c..ccf0397 100644
--- a/include/xmemory.h
+++ b/include/xmemory.h
@@ -138,7 +138,7 @@ Remalloc_again:
     CallSite callsite;
     objectHeader * obj = getObjectHeader(ptr);
 
-    callsite.fetch(2);
+    callsite.fetch(CALL_SITE_DEPTH);
 
     // Check whether current callsite is the same as before. If it is
     // not the same, we have to cleanup all information about the old
@@ -165,6 +165,7 @@ Remalloc_again:
     atomic::increment((unsigned long *)&allocTimes);
   #endif
   }
+  //fprintf(stderr, "xmemory malloc sz %d ptr %p\n", sz, ptr);
 #else
   if(sz <= xdefines::LARGE_CHUNK) 
     ptr = _bheap.malloc (_heapid, sz);
@@ -210,6 +211,7 @@ Remalloc_again:
   }
  
   void openProtection() {
+    fprintf(stderr, "%d: starting on protection\n", getpid());
     _globals.openProtection();
     _bheap.openProtection();
     _protectLargeHeap = true;
@@ -461,14 +463,17 @@ Remalloc_again:
 
   inline void enableCheck() {
     atomic::atomic_set(&_doChecking, 1);
+   // fprintf(stderr, "%d: ENABLE checking\n", getpid());
   }
 
   inline void disableCheck() {
+   // fprintf(stderr, "%d: DISABLE checking\n", getpid());
     atomic::atomic_set(&_doChecking, 0);
   } 
 
   void doPeriodicChecking () {
     if(_doChecking == 1) {
+   //   fprintf(stderr, "Do periodicchecking with doChecking 1*******\n");
       stopCheckingTimer();
       _globals.periodicCheck();
       _bheap.periodicCheck();
@@ -515,6 +520,9 @@ public:
 #ifdef DETECT_FALSE_SHARING
     xmemory::getInstance().disableCheck();
 #endif
+    char string[256];
+
+//    fprintf(stderr, "%d: inside the signal handler\n", getpid());
     void * addr = siginfo->si_addr; // address of access
 
     // Check if this was a SEGV that we are supposed to trap.
@@ -527,9 +535,12 @@ public:
                 xdefines::PageSize,
                 PROT_READ | PROT_WRITE);
 
+      sprintf(string, "%d: capture the memory access error at %p\n", getpid(), addr);
+  
     // It is a write operation. Handle that.
       xmemory::getInstance().handleWrite (addr);
     } else if (siginfo->si_code == SEGV_MAPERR) {
+      sprintf(string, "%d: capture the memory map error at %p\n", getpid(), addr);
       fprintf (stderr, "%d : map error with addr %p!\n", getpid(), addr);
       ::abort();
     } else {
@@ -538,6 +549,7 @@ public:
       ::abort();
     }
 
+    write(1, string, strlen(string));
 #ifdef DETECT_FALSE_SHARING
     xmemory::getInstance().enableCheck();
 #endif
diff --git a/include/xpersist.h b/include/xpersist.h
index 6468978..6bc6520 100644
--- a/include/xpersist.h
+++ b/include/xpersist.h
@@ -50,9 +50,10 @@ extern "C" int madvise(caddr_t addr, size_t len, int advice);
  * @brief Makes a range of memory persistent and consistent.
  *
  * @author Emery Berger <http://www.cs.umass.edu/~emery>
+ * @author Tongping Liu <http://www.cs.umass.edu/~tonyliu>
  */
 template <class Type,
-    long NElts = 1>
+    unsigned long NElts = 1>
 class xpersist {
 public:
   typedef std::pair<int, void *> objType;
@@ -312,18 +313,18 @@ public:
   }
 
 #ifdef DETECT_FALSE_SHARING
-  void writeProtect(void * start, int size) {
+  void writeProtect(void * start, unsigned long size) {
    //if(_isHeap) //FIXME
      mprotect (start, size, PROT_READ);
     return;
   }
 
-  void removeProtect(void * start, int size) {
+  void removeProtect(void * start, unsigned long size) {
     mprotect (start, size, PROT_READ|PROT_WRITE);
     return;
   }
   
-  void* mapRdPrivate(void * start, int size) {
+  void* mapRdPrivate(void * start, unsigned long size) {
     void * area;
     int  offset = (intptr_t)start - (intptr_t)base();
 
@@ -363,7 +364,7 @@ public:
     return (area);
   }
 
-  void *mapRwShared(void * start, int size) {
+  void *mapRwShared(void * start, unsigned long size) {
     void * area;
     int  offset = (intptr_t)start - (intptr_t)base();
 
@@ -383,7 +384,7 @@ public:
     return (area);
  }
 #else
-  void *writeProtect(void * start, int size) {
+  void *writeProtect(void * start, unsigned long size) {
     void * area;
     int  offset = (intptr_t)start - (intptr_t)base();
 
@@ -403,7 +404,7 @@ public:
   }
 
 
-  void * removeProtect(void * start, int size) {
+  void * removeProtect(void * start, unsigned long size) {
     void * area;
     int  offset = (intptr_t)start - (intptr_t)base();
 
@@ -491,7 +492,7 @@ public:
   }
 
   /// @return the size in bytes of the underlying object.
-  inline long size (void) const {
+  inline unsigned long size (void) const {
     if(_isHeap) 
       return NElts * sizeof(Type);
     else
@@ -582,9 +583,12 @@ public:
     struct pageinfo * pageinfo;
     int pageNo;
 
+      fprintf(stderr, "Try to check those dirty page\n", pageNo);
     for (dirtyListType::iterator i = _privatePagesList.begin(); i != _privatePagesList.end(); i++) {
       pageinfo = (struct pageinfo *)i->second;
       pageNo = pageinfo->pageNo;
+  
+      fprintf(stderr, "Checking pageNo %d\n", pageNo);
       if(pageinfo->shared != true) {
         // Check whether one un-shared page becomes shared now?
         int curUsers = atomic::atomic_read(&_pageUsers[pageNo]);
@@ -725,7 +729,7 @@ public:
     __m128i * twinbuf  = (__m128i *) twin;
     __m128i * destbuf  = (__m128i *) dest;
     // Some vectorizing pragamata here; not sure if gcc implements them.
-  #pragma vector always
+ // #pragma vector always
     for (int i = 0; i < xdefines::PageSize / sizeof(__m128i); i++) {
   
       __m128i localChunk, twinChunk, destChunk;
diff --git a/source/libsheriff.cpp b/source/libsheriff.cpp
index 3630a3b..4f97d51 100644
--- a/source/libsheriff.cpp
+++ b/source/libsheriff.cpp
@@ -344,6 +344,7 @@ extern "C" {
   }
 
   int pthread_join (pthread_t tid, void ** val) {
+    fprintf(stderr, "Call joining\n");
     xrun::getInstance().join ((void *)tid, val);
     return 0;
   }
diff --git a/source/xthread.cpp b/source/xthread.cpp
index 9d5e12e..5c3c186 100644
--- a/source/xthread.cpp
+++ b/source/xthread.cpp
@@ -29,6 +29,7 @@ void xthread::join (xrun * runner,
             void * v,
             void ** result)
 {
+  fprintf(stderr, "%d: joining thread\n", getpid());
 
   // Return immediately if the thread argument is NULL.
   if (v == NULL) {
@@ -136,7 +137,7 @@ void * xthread::forkSpawn (xrun * runner,
     // We're in...
     _nestingLevel++;
 
-  //fprintf(stderr, "Create thread %d\n", mypid);
+  fprintf(stderr, "Create thread %d\n", mypid);
 #ifdef MULTITHREAD_SUPPORT
 	// Create those helpers.
 	runner->creatHelpers();
@@ -147,10 +148,11 @@ void * xthread::forkSpawn (xrun * runner,
     runner->closeParentSharedBlocks();
 #endif
 
+    //while(1); 
     // Run the thread...
     run_thread (runner, fn, t, arg);
 
-//	fprintf(stderr, "%d : EXIT thread\n", mypid);
+	fprintf(stderr, "%d : EXIT thread\n", mypid);
     // and we're out.
     _nestingLevel--;
 
